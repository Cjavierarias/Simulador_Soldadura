<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
  <title>Simulador Soldadura — Fix</title>

  <!-- A-Frame (versión compatible) -->
  <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
  <!-- AR.js compatible con A-Frame 1.2.0 -->
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.3.2/aframe/build/aframe-ar.js"></script>

  <!-- OpenCV.js: se usará cv.onRuntimeInitialized; si tu build no incluye calib3d se usará fallback -->
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>

  <style>
    html,body { height:100%; margin:0; background:#111; color:#eee; font-family:Arial,Helvetica,sans-serif; }
    /* pon el video por encima de la escena AR */
    #videoWrap { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:#000; z-index:999; }
    a-scene { position:fixed; inset:0; z-index: 1; pointer-events: none; } /* AR en fondo, sin capturar clicks */

    video#videoInput { width:100%; height:100%; object-fit:cover; background:#000; }
    #ui { position: absolute; left:10px; top:10px; z-index:999; background: rgba(0,0,0,0.55); padding:10px; border-radius:10px; min-width:260px; }
    button { padding:8px 12px; border-radius:8px; border: none; background:#0a84ff; color:white; font-weight:600; margin:4px 2px; }
    #status { margin-top:6px; font-size:13px; color:#ffd; }
    #errors { color:#ff9a9a; font-size:13px; margin-top:6px; white-space:pre-wrap; max-height:100px; overflow:auto; }
    .small { font-size:12px; color:#ccc; }
    #angleBar { height:12px; border-radius:6px; background:#444; margin-top:6px; overflow:hidden; }
    #angleBar > i { display:block; height:100%; width:0%; background:green; }
    #canvasOut { display:none; }
  </style>
</head>
<body>
  <!-- A-Frame scene (overlay AR) -->
  <a-scene embedded arjs='sourceType: webcam; debugUIEnabled: false;' vr-mode-ui="enabled: false" style="position:fixed; inset:0; z-index:2; pointer-events:none;">
    <a-entity camera></a-entity>
  </a-scene>

  <div id="videoWrap">
    <video id="videoInput" playsinline autoplay muted></video>
  </div>

  <div id="ui">
    <div style="font-weight:800">Simulador Soldadura — Fix</div>
    <div class="small">Patrón: configurable (4×4 ejemplo)</div>
    <div style="margin-top:8px;">
      <button id="btnStart">Iniciar cámara</button>
      <button id="btnStop">Detener cámara</button>
      <button id="btnCalib">Calibración rápida</button>
      <button id="btnDownload">Descargar log</button>
    </div>

    <div id="status">Estado: esperando</div>
    <div id="errors"></div>

    <div id="metrics" style="margin-top:8px; display:none;">
      <div><strong>Ángulo:</strong> <span id="angleVal">—</span>°</div>
      <div><strong>Vel (mm/s):</strong> <span id="speedVal">—</span></div>
      <div><strong>Dist Z (mm):</strong> <span id="distVal">—</span></div>
      <div id="angleBar"><i id="angleFill"></i></div>
      <div id="bigState" class="small">Estado: —</div>
    </div>
  </div>

  <canvas id="canvasOut"></canvas>

<script>
/* =========================
   CONFIG
   ========================= */
const cfg = {
  patternCols: 3, // esquinas internas (para patrón 4x4 cuadrados -> 3x3)
  patternRows: 3,
  squareSizeMM: 100.0, // ajustar al patrón real
  angleMin: -10, angleMax: 10,
  sampleMs: 60,
  smoothingAlpha: 0.6
};

/* =========================
   ESTADO RUNTIME
   ========================= */
let stream = null;
let video = document.getElementById('videoInput');
let canvas = document.getElementById('canvasOut');
let ctx = canvas.getContext('2d', { willReadFrequently: true });
let processing = false;
let lastTime = null;
let lastPose = null;
let poseHistory = [];
let evaluating = false;
let logData = [];
let cameraMatrix = null;
let distCoeffs = null;
let hasCalib3d = false;

/* UI refs */
const statusEl = document.getElementById('status');
const errorsEl = document.getElementById('errors');
const metricsDiv = document.getElementById('metrics');
const angleVal = document.getElementById('angleVal');
const speedVal = document.getElementById('speedVal');
const distVal = document.getElementById('distVal');
const angleFill = document.getElementById('angleFill');
const bigState = document.getElementById('bigState');

/* botones */
document.getElementById('btnStart').addEventListener('click', startCamera);
document.getElementById('btnStop').addEventListener('click', stopCamera);
document.getElementById('btnCalib').addEventListener('click', quickCalib);
document.getElementById('btnDownload').addEventListener('click', downloadLog);

/* =========================
   HELPERS UI
   ========================= */
function setStatus(s) { statusEl.textContent = 'Estado: ' + s; console.log('[STATUS]', s); }
function setError(e) { errorsEl.textContent = String(e); console.error('[ERR]', e); }

/* =========================
   OPEN CV INITIALIZATION
   ========================= */
function startWhenOpenCVReady() {
  // wait until cv is available and runtime initialized
  if (typeof cv === 'undefined') {
    setError('OpenCV no cargado. Revisa la URL de opencv.js.');
    return;
  }
  if (cv.getBuildInformation) {
    // already ready
    afterCvReady();
  } else {
    setStatus('Esperando OpenCV runtime...');
    cv['onRuntimeInitialized'] = () => {
      afterCvReady();
    };
  }
}

function afterCvReady() {
  try {
    console.log('OpenCV build info:\n', cv.getBuildInformation());
    hasCalib3d = /calib3d/i.test(cv.getBuildInformation());
  } catch(e) {
    console.warn('No se pudo leer build info', e);
    hasCalib3d = false;
  }
  setStatus('OpenCV listo. calib3d: ' + (hasCalib3d ? 'SI' : 'NO - fallback activado'));
  // start camera only after user clicks Start (we don't auto-start)
}

/* =========================
   CAMERA CONTROL
   ========================= */
// Reemplaza tu startCamera() por esta versión robusta
async function startCamera() {
  setError('');
  setStatus('Buscando dispositivos de cámara...');
  // Si ya hay un stream abierto, ciérralo primero
  try { if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; video.srcObject = null; } } catch(e){ console.warn('Error cerrando stream previo', e); }

  // Obtener lista de dispositivos y elegir un candidate deviceId para la cámara trasera si existe
  let devices = [];
  try {
    devices = await navigator.mediaDevices.enumerateDevices();
  } catch (e) {
    console.warn('enumerateDevices falló', e);
  }
  const videoInputs = devices.filter(d => d.kind === 'videoinput');
  console.log('videoInputs disponibles:', videoInputs);
  let chosenDeviceId = null;

  // intentar preferir un label con "back" o "rear" o "environment" si están presentes
  for (const d of videoInputs) {
    const lab = (d.label || '').toLowerCase();
    if (lab.includes('back') || lab.includes('rear') || lab.includes('environment')) {
      chosenDeviceId = d.deviceId;
      break;
    }
  }
  // si no encontramos por label, tomamos el primero
  if (!chosenDeviceId && videoInputs.length) chosenDeviceId = videoInputs[0].deviceId;

  // Si no hay devices, informar claramente
  if (!chosenDeviceId) {
    setError('No se encontraron dispositivos de video en este equipo. Revisa permisos o hardware.');
    setStatus('Sin dispositivo de cámara');
    return;
  }

  // lista de constraints a intentar (de mayor a menor)
  const constraintAttempts = [
    { video: { deviceId: { exact: chosenDeviceId }, width: { ideal: 1280 }, height: { ideal: 720 } }, audio: false },
    { video: { deviceId: { exact: chosenDeviceId }, width: { ideal: 640 }, height: { ideal: 480 } }, audio: false },
    { video: { deviceId: { exact: chosenDeviceId } }, audio: false }, // cualquier resolución
    // fallback: intentar sin deviceId (que deje elegir al navegador)
    { video: { facingMode: "environment", width: { ideal: 640 }, height: { ideal: 480 } }, audio: false },
    { video: true, audio: false }
  ];

  // función interna para intentar obtener stream con reintentos
  async function tryConstraintsList(constraintsList, maxRetries = 3) {
    for (let i = 0; i < constraintsList.length; i++) {
      const c = constraintsList[i];
      let attempt = 0;
      let backoff = 300;
      while (attempt < maxRetries) {
        try {
          setStatus(`Intentando cámara (modo ${i+1}/${constraintsList.length}, intento ${attempt+1})...`);
          const s = await navigator.mediaDevices.getUserMedia(c);
          // al llegar aquí, éxito: asignar y salir
          stream = s;
          video.srcObject = stream;
          await video.play().catch(err => console.warn('video.play() rejected', err));
          setStatus('Cámara iniciada correctamente');
          // mostrar settings
          try {
            const track = stream.getVideoTracks()[0];
            const settings = track.getSettings && track.getSettings();
            if (settings) setStatus(`Cámara: ${settings.width}x${settings.height} - facingMode: ${settings.facingMode || 'n/a'}`);
          } catch (e) { /* no crítico */ }
          return true;
        } catch (err) {
          console.warn('getUserMedia intento error', err);
          // Manejo específico de errores
          if (err && err.name === 'NotReadableError') {
            // puede ser cámara en uso -> reintentar con backoff
            setError('NotReadableError: la cámara parece estar ocupada por otra app. Cierra otras apps y reintenta.');
            // corta: reintenta unas pocas veces
            await new Promise(r => setTimeout(r, backoff));
            attempt++;
            backoff *= 1.8;
            continue;
          } else if (err && (err.name === 'OverconstrainedError' || err.name === 'ConstraintNotSatisfiedError')) {
            // ese constraint no se puede cumplir: pasar al siguiente constraintsList
            setError('OverconstrainedError: la resolución o constraint no es soportada. Probando otra configuración.');
            console.warn('Constraint no satisfecho, pasando al siguiente constraint.');
            break; // break inner loop y probar siguiente constraints
          } else if (err && err.name === 'NotAllowedError') {
            setError('Permiso denegado: permite el uso de cámara en el diálogo del navegador y en ajustes del dispositivo.');
            return false;
          } else if (err && err.name === 'SecurityError') {
            setError('SecurityError: contexto no seguro (usa HTTPS o localhost).');
            return false;
          } else {
            setError('Error abriendo la cámara: ' + (err && err.message ? err.message : String(err)));
            // reintentar 1 vez más por si acaso
            attempt++;
            await new Promise(r => setTimeout(r, backoff));
            backoff *= 1.8;
          }
        }
      } // end while attempts
      // si llegamos aquí sin return, probar siguiente constraint
    } // end for constraintsList
    return false;
  }

  const ok = await tryConstraintsList(constraintAttempts, 3);
  if (!ok) {
    setStatus('No pudo iniciarse la cámara con las configuraciones probadas.');
    // sugerencia final para el usuario
    errorsEl.textContent += '\nSi el problema persiste: 1) cierra apps que usen la cámara, 2) reinicia el dispositivo, 3) prueba con otro navegador (Chrome/Edge), 4) revisa permisos de cámara.';
  } else {
    // configurar canvas tamaño real y lanzar procesado si corresponde
    canvas.width = video.videoWidth || 1280;
    canvas.height = video.videoHeight || 720;
    processing = true;
    lastTime = performance.now();
    processLoop();
  }
}


function stopCamera() {
  processing = false;
  if (stream) {
    stream.getTracks().forEach(t => t.stop());
    stream = null;
    video.srcObject = null;
    setStatus('Cámara detenida');
  } else setStatus('No había cámara activa');
}

/* =========================
   DETECCIÓN / FALLBACK
   ========================= */
function hasFindChessboard() {
  return hasCalib3d && (typeof cv.findChessboardCorners === 'function');
}

// fallback: detecta esquinas con goodFeaturesToTrack (no garantiza orden)
function detectGridFallback(grayMat, expectedCount) {
  try {
    const maxCorners = expectedCount || (cfg.patternCols * cfg.patternRows);
    let corners = new cv.Mat();
    cv.goodFeaturesToTrack(grayMat, corners, maxCorners, 0.01, 10);
    let pts = [];
    for (let i=0; i<corners.rows; i++) {
      pts.push([corners.data32F[i*2], corners.data32F[i*2+1]]);
    }
    corners.delete();
    // ordenar por Y luego X para intentar estructura en malla
    pts.sort((a,b)=> (a[1]-b[1]) || (a[0]-b[0]));
    return pts;
  } catch(e) {
    console.warn('detectGridFallback error', e);
    return [];
  }
}

/* =========================
   PROCESS LOOP: detecta patrón / solvePnP (si es posible)
   ========================= */
function processLoop() {
  if (!processing) return;
  try {
    // copiar frame al canvas y leer con OpenCV
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    let src = cv.imread(canvas);
    let gray = new cv.Mat();
    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

    let found = false;
    let cornersMat = null;

    // intentar ejecutar findChessboardCorners si está disponible
    if (hasFindChessboard()) {
      let patternSize = new cv.Size(cfg.patternCols, cfg.patternRows);
      cornersMat = new cv.Mat();
      try {
        found = cv.findChessboardCorners(gray, patternSize, cornersMat, cv.CALIB_CB_ADAPTIVE_THRESH + cv.CALIB_CB_NORMALIZE_IMAGE);
        if (found) {
          // refinar esquinas
          cv.cornerSubPix(gray, cornersMat, new cv.Size(11,11), new cv.Size(-1,-1),
            new cv.TermCriteria(cv.TermCriteria_EPS + cv.TermCriteria_MAX_ITER, 30, 0.1));
        }
      } catch(e) {
        console.warn('findChessboardCorners lanzamiento error', e);
        found = false;
        cornersMat.delete && cornersMat.delete();
        cornersMat = null;
      }
    } else {
      // fallback: detectGridFallback
      const pts = detectGridFallback(gray, cfg.patternCols * cfg.patternRows);
      if (pts.length >= cfg.patternCols * cfg.patternRows) {
        found = true;
        cornersMat = cv.Mat.zeros(pts.length, 1, cv.CV_32FC2);
        for (let i=0;i<pts.length;i++){
          cornersMat.data32F[i*2] = pts[i][0];
          cornersMat.data32F[i*2+1] = pts[i][1];
        }
      } else {
        found = false;
      }
    }

    if (found && cornersMat) {
      // preparar objetos 3D (en mm)
      let objPoints = [];
      for (let r=0;r<cfg.patternRows;r++){
        for (let c=0;c<cfg.patternCols;c++){
          objPoints.push(c*cfg.squareSizeMM);
          objPoints.push(r*cfg.squareSizeMM);
          objPoints.push(0.0);
        }
      }
      // cameraMatrix fallback simple si no calibrada
      if (!cameraMatrix) {
        const f = canvas.width; // estimación grosso modo
        cameraMatrix = cv.matFromArray(3,3,cv.CV_64F, [f,0,canvas.width/2, 0,f,canvas.height/2, 0,0,1]);
        distCoeffs = cv.Mat.zeros(1,5,cv.CV_64F);
      }

      // construir Mats para solvePnP: objPoints Nx1 CV_32FC3, imgPoints Nx1 CV_32FC2
      let objMat = cv.matFromArray(cfg.patternCols*cfg.patternRows, 1, cv.CV_32FC3, objPoints);
      // cornersMat ya tiene formato Nx1 CV_32FC2 o CV_32FC2 según build; si no, convertir
      let imgMat = cornersMat;

      // rvec, tvec
      let rvec = new cv.Mat(), tvec = new cv.Mat();
      try {
        const success = cv.solvePnP(objMat, imgMat, cameraMatrix, distCoeffs, rvec, tvec, false, cv.SOLVEPNP_ITERATIVE);
        if (success) {
          // rot matrix
          let rotMat = new cv.Mat();
          cv.Rodrigues(rvec, rotMat);
          const euler = rotMatToEuler(rotMat);
          const now = performance.now();
          const dt = (now - (lastTime||now))/1000.0;
          lastTime = now;

          const zmm = tvec.data64F ? tvec.data64F[2] : (tvec.data32F ? tvec.data32F[2] : tvec.data[2]);
          let speed = 0;
          if (lastPose) {
            const dx = (tvec.data64F? tvec.data64F[0] : tvec.data32F? tvec.data32F[0]:0) - (lastPose.t[0]||0);
            const dy = (tvec.data64F? tvec.data64F[1] : tvec.data32F? tvec.data32F[1]:0) - (lastPose.t[1]||0);
            const dz = (tvec.data64F? tvec.data64F[2] : tvec.data32F? tvec.data32F[2]:0) - (lastPose.t[2]||0);
            const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
            speed = dt>0 ? dist/dt : 0;
          }
          const anglePitch = euler.pitch;
          const angleSmooth = smooth(anglePitch, lastPose?lastPose.angles.pitch:null, cfg.smoothingAlpha);
          const distSmooth = smooth(zmm, lastPose?lastPose.t[2]:null, cfg.smoothingAlpha);
          const speedSmooth = smooth(speed, lastPose?lastPose.speed:null, cfg.smoothingAlpha);

          updateUI(angleSmooth, speedSmooth, distSmooth);

          const pose = { t: [ tvec.data64F? tvec.data64F[0] : (tvec.data32F? tvec.data32F[0]:0),
                                tvec.data64F? tvec.data64F[1] : (tvec.data32F? tvec.data32F[1]:0),
                                tvec.data64F? tvec.data64F[2] : (tvec.data32F? tvec.data32F[2]:0) ],
                         r: [ rvec.data64F? rvec.data64F[0]:(rvec.data32F? rvec.data32F[0]:0),
                              rvec.data64F? rvec.data64F[1]:(rvec.data32F? rvec.data32F[1]:0),
                              rvec.data64F? rvec.data64F[2]:(rvec.data32F? rvec.data32F[2]:0) ],
                         angles: euler,
                         speed: speedSmooth,
                         time: now };
          lastPose = pose;
          poseHistory.push(pose);
          if (poseHistory.length>200) poseHistory.shift();

          if (evaluating) {
            logData.push({time: now, angle: angleSmooth, speed: speedSmooth, dist: distSmooth});
            // alarmas (puedes integrar audio)
            if (angleSmooth > cfg.angleMax) bigState.textContent = 'Fuera (alto)';
            else if (angleSmooth < cfg.angleMin) bigState.textContent = 'Fuera (bajo)';
            else bigState.textContent = 'Dentro';
          }

          rotMat.delete();
        } else {
          bigState.textContent = 'solvePnP falló';
        }
      } catch(e) {
        console.warn('solvePnP error', e);
      } finally {
        rvec.delete(); tvec.delete(); objMat.delete();
      }
    } else {
      bigState.textContent = 'Patrón no detectado';
      updateUI(null,null,null);
    }

    // liberar
    src.delete(); gray.delete();
    if (cornersMat) cornersMat.delete();

  } catch (err) {
    console.error('processLoop err', err);
    setError(String(err));
  } finally {
    // siguiente
    setTimeout(processLoop, cfg.sampleMs);
  }
}

/* =========================
   UTILIDADES: rotMat -> Euler, smoothing, UI update
   ========================= */
function rotMatToEuler(R) {
  // R Mat 3x3; puede ser data64F o data32F
  const r = R.data64F || R.data32F;
  const r00=r[0], r01=r[1], r02=r[2], r10=r[3], r11=r[4], r12=r[5], r20=r[6], r21=r[7], r22=r[8];
  let sy = Math.sqrt(r00*r00 + r10*r10);
  let singular = sy < 1e-6;
  let x,y,z;
  if (!singular) {
    x = Math.atan2(r21, r22);
    y = Math.atan2(-r20, sy);
    z = Math.atan2(r10, r00);
  } else {
    x = Math.atan2(-r12, r11);
    y = Math.atan2(-r20, sy);
    z = 0;
  }
  return { roll: x*180/Math.PI, pitch: y*180/Math.PI, yaw: z*180/Math.PI };
}

function smooth(v, prev, a) { if (prev==null || prev==undefined) return v; return a*v + (1-a)*prev; }

function updateUI(angle, speed, dist) {
  angleVal.textContent = angle==null? '—' : angle.toFixed(1);
  speedVal.textContent = speed==null? '—' : Math.round(speed);
  distVal.textContent = dist==null? '—' : Math.round(dist);
  // barra de ángulo relativa
  const span = Math.max(Math.abs(cfg.angleMin), Math.abs(cfg.angleMax)) || 20;
  const pct = angle==null? 0 : Math.min(100, Math.abs(angle)/span*100);
  angleFill.style.width = pct + '%';
  if (angle==null) angleFill.style.background = '#666';
  else if (angle < cfg.angleMin) angleFill.style.background = '#b22222';
  else if (angle > cfg.angleMax) angleFill.style.background = '#ffcc00';
  else angleFill.style.background = '#22aa22';
}

/* =========================
   CALIBRACIÓN RÁPIDA & LOG
   ========================= */
function quickCalib() {
  const d = prompt('Coloca el patrón a una distancia conocida (mm). Ej: 500', '500');
  if (!d) return alert('Se canceló calibración rápida.');
  const distMm = parseFloat(d);
  if (isNaN(distMm) || distMm<=0) return alert('Distancia inválida');
  // estimación: establecer focal basada en suposición que patrón ocupa ~ width pix
  // Esta es solo una estimación rápida; para precisión usa calibrateCamera offline.
  const f = canvas.width * (distMm / (cfg.patternCols * cfg.squareSizeMM));
  cameraMatrix = cv.matFromArray(3,3,cv.CV_64F, [f,0,canvas.width/2, 0,f,canvas.height/2, 0,0,1]);
  distCoeffs = cv.Mat.zeros(1,5,cv.CV_64F);
  setStatus('Calibración rápida aplicada (estimada).');
}

/* =========================
   EVALUACIÓN / LOG
   ========================= */
function startEval() { evaluating = true; logData = []; setStatus('Evaluando...'); }
function stopEval() { evaluating = false; setStatus('Evaluación finalizada. Registros: ' + logData.length); }

function downloadLog() {
  const blob = new Blob([JSON.stringify(logData, null, 2)], {type: 'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'soldadura_log.json'; a.click();
  URL.revokeObjectURL(url);
}

/* =========================
   ON LOAD
   ========================= */
window.addEventListener('load', () => {
  startWhenOpenCVReady();
  setStatus('Listo. Haz click en "Iniciar cámara". Si OpenCV no tiene calib3d, se usará un fallback.');
});

/* =========================
   UTIL - DEBUG: mostrar build info en consola
   ========================= */
window.showCvInfo = function() {
  try { console.log(cv.getBuildInformation()); } catch(e) { console.warn('cv info no disponible', e); }
};

</script>
</body>
</html>
